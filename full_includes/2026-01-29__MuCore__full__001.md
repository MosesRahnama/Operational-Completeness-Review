Purpose: Evidence extract (failed_attempts/code) documenting a failure or relevance; Duplicate of Legacy\MetaMD_Archive\MuCore.md.
Contents: Metadata header + excerpt from the source file.
Context: Full copy of MuCore.md containing ordinal inequality helpers and a mu-drop lemma used in KO7 termination attempts.
Source: Legacy/MetaMD_Archive/MuCore.md
SHA256: 4A663976D673AEA17AE4C6DEF5B61874386865E5AD89B4705A25B82D9C85F20F
FailureExplanation: Supports the ordinal mu infrastructure used in failed or partial SN proofs, illustrating the reliance on complex ordinal lemmas.
FailureModeTags: nonconvergence

---

import OperatorKernelO6.Kernel
import OperatorKernelO6.Meta.Termination
import Mathlib.SetTheory.Ordinal.Principal

namespace MuCore
open Ordinal
open OperatorKernelO6
open OperatorKernelO6.Trace
open MetaSN                 -- was `OperatorKernelO6.MetaSN`; correct name

-- set_option trace.Meta.Tactic.simp true
-- set_option diagnostics.threshold 100
-- set_option diagnostics true
-- set_option autoImplicit false
-- set_option maxRecDepth 500
-- set_option pp.explicit true
-- set_option pp.universes true
-- set_option trace.Meta.isDefEq true
-- set_option trace.Meta.debug true
-- set_option trace.Meta.Tactic.simp.rewrite true
-- set_option trace.linarith true
-- set_option trace.compiler.ir.result true

/-- small bridge: `x ? ?^x` (base ?). -/
private theorem le_omega_pow (x : Ordinal) : x ? omega0 ^ x :=
  Ordinal.right_le_opow (a := omega0) (b := x) one_lt_omega0

/-- helper: for all ordinals, `3 + (x + 1) ? x + 4`. -/private lemma add3_plus1_le_plus4 (x : Ordinal) :
  (3 : Ordinal) + (x + 1) ? x + 4 := by
  by_cases hx? : x < omega0
  ? -- finite case: `x = n`
    rcases Ordinal.lt_omega0.1 hx? with ?n, rfl?
    -- The goal is now: 3 + (?n + 1) ? ?n + 4
    -- Use explicit arithmetic
    -- Show 3 + (n + 1) ? n + 4 directly
    have : (3 : Ordinal) + ((n : Ordinal) + 1) = ((n : Ordinal) + 4) := by
      norm_cast
      ring
    exact le_of_eq this
  ? -- infinite case: `? ? x` ? `3 + x = x`
    have hx' : omega0 ? x := le_of_not_gt hx?
    have absorb : (3 : Ordinal) + x = x :=
      (Ordinal.natCast_add_of_omega0_le (n := 3) hx')
    -- For infinite x: 3 + (x + 1) = (3 + x) + 1 = x + 1 ? x + 4
    calc (3 : Ordinal) + (x + 1)
        = (3 + x) + 1 := by rw [add_assoc]
    _ = x + 1 := by rw [absorb]
    _ ? x + 4 := by apply add_le_add_left; norm_num

/-- helper: for all ordinals, `2 + (x + 1) ? x + 3`. -/
private lemma add2_plus1_le_plus3 (x : Ordinal) :
  (2 : Ordinal) + (x + 1) ? x + 3 := by
  by_cases hx? : x < omega0
  ? -- finite case: `x = n`
    rcases Ordinal.lt_omega0.1 hx? with ?n, rfl?
    -- The goal is now: 2 + (?n + 1) ? ?n + 3
    -- Show 2 + (n + 1) ? n + 3 directly
    have : (2 : Ordinal) + ((n : Ordinal) + 1) = ((n : Ordinal) + 3) := by
      norm_cast
      ring
    exact le_of_eq this
  ? -- infinite case: `? ? x`
    have hx' : omega0 ? x := le_of_not_gt hx?
    have absorb : (2 : Ordinal) + x = x :=
      (Ordinal.natCast_add_of_omega0_le (n := 2) hx')
    calc (2 : Ordinal) + (x + 1)
        = (2 + x) + 1 := by rw [add_assoc]
    _ = x + 1 := by rw [absorb]
    _ ? x + 3 := by apply add_le_add_left; norm_num

/-- Derived bound used in `eqW_diff`:  ?^3?(x+1) ? ?^(x+4). -/
lemma termA_le (x : Ordinal) :
  (omega0 ^ (3 : Ordinal)) * (x + 1) ? omega0 ^ (x + 4) :=
  MetaSN.termA_le x

/-- Derived bound used in `eqW_diff`:  ?^2?(x+1) ? ?^(x+3). -/
lemma termB_le (x : Ordinal) :
  (omega0 ^ (2 : Ordinal)) * (x + 1) ? omega0 ^ (x + 3) :=
  MetaSN.termB_le x

/-- **Key ??drop for `eqW_diff`** (independent of the `a ? b` premise):
    `? (integrate (merge a b)) < ? (eqW a b)`. -/
theorem mu_lt_eq_diff (a b : Trace) :
  MetaSN.mu (.integrate (.merge a b)) < MetaSN.mu (.eqW a b) :=
  -- Just use the working theorem from Termination.lean
  MetaSN.mu_lt_eq_diff a b

/-- local strict-mono bridge: if `a < b` then `?^a < ?^b` -/
private lemma opow_lt_opow_right {a b : Ordinal} (h : a < b) :
    omega0 ^ a < omega0 ^ b := by
  -- `isNormal_opow` supplies strict monotonicity for `?`-powers
  simpa using ((isNormal_opow (a := omega0) one_lt_omega0).strictMono h)

end MuCore

-- re-export for downstream files
export MuCore (mu_lt_eq_diff)




