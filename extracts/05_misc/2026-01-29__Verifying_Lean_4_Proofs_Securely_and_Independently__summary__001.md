Context: Background research memo; not a proof artifact.
Source: C:\Users\Moses\OpComp\MUST_Review\important_2\Research\Verifying_Lean_4_Proofs_Securely_and_Independently.md
SHA256: ECEA690EE59CA7DB6C67AE7FE78FF979EDC133402159411F0B5BDCE600FF5F4C
FailureExplanation: Background research memo; not a proof artifact.
FailureModeTags: 

Excerpt:
> # Verifying Lean 4 Proofs Securely and Independently
> *Converted from: Verifying Lean 4 Proofs Securely and Independently.docx*
> ---
> # Verifying Lean 4 Proofs Securely and Independently
> ## Lean’s Own Verification and Termination Checks
> Lean 4’s built-in type checker and kernel are the primary tools to verify proofs. When you run Lean on your code (for example, via lake build or the VS Code extension), it will type-check every definition and proof. Lean’s trusted kernel guarantees that any proof which passes this check is logically correct[1][2]. In practice, this means if the AI-generated proofs type-check with no errors or warnings, Lean has formally verified them as correct relative to your axioms and definitions. Lean automatically checks termination and totality of functions as well. All functions must either obviously terminate or use a well-founded measure; otherwise you must mark them partial/unsafe (which you should avoid in proofs)[3]. This ensures that recursive definitions (like those using multiset orders or ordinals) truly are terminating, barring any explicit override.
> When using Lean locally, no data is sent externally, so your sensitive theory remains private. It’s wise to disable any network features or telemetry in your editor and avoid external dependencies. By default, Lean does not upload code anywhere – the checking is done on your machine. Lean will also flag incomplete proofs: if an AI introduced a sorry (an unfinished proof), Lean emits a warning (“declaration uses ‘sorry’”) and treats it as an axiom. You can detect these by searching for sorry in your code or using #print axioms on a theorem to see if sorryAx appears[4]. In short, simply running Lean on the project is the first and most important verification step – it confirms all proofs, ensures termination, and will alert you to any unsound steps. Keep in mind, however, that Lean verifies correctness with respect to the formal statements you provided; it cannot tell if the formal theorem truly captures your intended theory – that gap is something only a careful human review can bridge[5].
> ## Isolated Continuous Integration (CI) and Build Environments
> To continually verify proofs without exposing your code, you can set up a local or offline CI pipeline. For example, you might run a Jenkins server or a GitLab CI runner on a machine under your control (no public cloud) that builds your Lean project on each change. This ensures that any errors introduced by edits or AI suggestions are caught immediately, in a controlled environment. Using a containerization approach is highly effective here: you can run Lean in a Docker container with no internet access. The Lean community provides Docker images (e.g. leanprovercommunity/lean4) that contain Lean 4 and its tools. By using such an image, you can mount your project into the container and run the build – all proofs will be checked inside the sandbox. This setup guarantees privacy because your code never leaves the container, and the container itself can be run on an offline machine[6]. For instance, you could create a Docker container that runs lake build on your project; if the build fails (due to a broken proof or non-termination), the container exits with an error, alerting you to a problem.
> Using VS Code offline: If you prefer an interactive environment, you can install Lean and VS Code on an air-gapped computer or use VS Code’s remote containers extension to work inside a locally-hosted Docker container. This way, all the Lean checking (which happens in the Lean server) stays local. No code or proof obligations will be sent to any cloud service. Ensure features like mathlib’s online oleans cache are disabled or pointed to a local source to avoid any external fetch. In an offline CI setup, you should also avoid posting build logs to public sites since they might contain parts of your code. Keep the CI logs and artifacts on internal servers.
> Self-hosted runners: If you use a service like GitHub or GitLab, configure a self-hosted runner on your own machine. That runner can perform the Lean build without sending data to the cloud. The key is that the code repository should be private (or on an internal version control system), and the runner should not expose logs publicly. By combining these practices, you get the benefits of automated proof checking and regression testing, while fully maintaining privacy. In summary, an isolated CI or build environment continuously validates your Lean proofs and build, catching errors early, all without exposing your proprietary theory.
> ## Lean Code Auditing Tools (Axioms, Unsafe Code, and Incompleteness)
