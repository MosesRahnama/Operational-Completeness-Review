Context: SN_Opus.lean uses a double-exponent ordinal measure μ₂ and claims strict decrease for all rules.
Source: C:\Users\Moses\OpComp\MUST_Review\Legacy\Meta_Lean_Archive\SN_Opus.lean
SHA256: 5E38F7925DB096DE14FF4CE819AC4B9BFC02CF5D26326996A5BF0D92EFBA663D
FailureExplanation: Key rec_succ decrease relies on informal ordinal bounds/linarith-style steps and unstated monotonicity assumptions.
FailureModeTags: unsupported_inference

Excerpt:
> -- R_rec_succ: recΔ b s (delta n) → merge s (recΔ b s n)
> -- This is the crucial case that motivated the double-exponent construction
> theorem mu2_decrease_rec_succ (b s n : Trace) :
>     μ₂ (merge s (recΔ b s n)) < μ₂ (recΔ b s (delta n)) := by
>   unfold μ₂
>   apply double_exp_monotone
>   simp [baseLayer]
>   -- Key insight: delta wrapper creates exponential gap
>   have h1 : baseLayer n < Ordinal.omega0 * (1 + baseLayer n) := by
>     rw [Ordinal.mul_one_add]
>     exact Ordinal.lt_add_of_pos_left _ Ordinal.omega0_pos
>   have h2 : 2 + baseLayer n + baseLayer s + baseLayer b <
>             2 + (Ordinal.omega0 * (1 + baseLayer n)) + baseLayer s + baseLayer b := by
>     linarith [h1]
>   -- Merge bound ensures the result is smaller
>   have h3 : 1 + max (baseLayer s) (2 + baseLayer n + baseLayer s + baseLayer b) ≤
>             2 + baseLayer n + baseLayer s + baseLayer b := by
>     simp [max_def]
>     by_cases h : baseLayer s ≤ 2 + baseLayer n + baseLayer s + baseLayer b
>     · simp [h]
>       linarith
>     · simp [h]
>       linarith
>   linarith [h2, h3]
>
> -- R_eq_refl: eqW a a → void
