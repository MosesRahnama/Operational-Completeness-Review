Purpose: Evidence extract (failed_attempts/analysis) documenting a failure or relevance; Explicit `admit` leaves the core rec_succ comparison unfinished.
Contents: Metadata header + excerpt from the source file.
Context: SN_Phi.lean defines a complex Φ measure; the rec_succ proof contains an admit.
Source: MUST_Review/Legacy/Meta_Lean_Archive/SN_Phi.lean
SHA256: 97587658276D61268D48D943DA0CFAE6B0C5E04F01316D3F877FB794B3400544
FailureExplanation: Explicit `admit` leaves the core rec_succ comparison unfinished.
FailureModeTags: proof_obligation_stuck

Excerpt:
> /-- rec_succ: merge s (recΔ b s n) < recΔ b s (delta n). -/
> theorem phi_merge_lt_rec (b s n : Trace) :
>   phi (merge s (recΔ b s n)) < phi (recΔ b s (delta n)) := by
>   -- Let A = ω^(E(δ n, s)) be the head of the RHS
>   set A : Ordinal := omega0 ^ ((omega0 ^ (5 : Ordinal)) * (phi (delta n) + 1) + phi s + 6) with hA
>   -- 1) head bound: ω^3*(Φ s + 1) < A
>   have h_head1 : (omega0 ^ (3 : Ordinal)) * (phi s + 1) ≤ omega0 ^ (phi s + 4) := termA_le (x := phi s)
>   have h_head2 : phi s + 4 < phi s + 6 := by simpa using add_lt_add_left (by norm_num : (4 : Ordinal) < 6) (phi s)
>   have h_head3 : omega0 ^ (phi s + 4) < omega0 ^ (phi s + 6) := opow_lt_opow_right h_head2
>   have h_head4 : phi s + 6 ≤ (omega0 ^ (5 : Ordinal)) * (phi (delta n) + 1) + phi s + 6 := by
>     have : (0 : Ordinal) ≤ (omega0 ^ (5 : Ordinal)) * (phi (delta n) + 1) := zero_le _
>     simpa [add_comm, add_left_comm, add_assoc] using add_le_add_right this (phi s + 6)
>   have h_head : (omega0 ^ (3 : Ordinal)) * (phi s + 1) < A := by
>     have := lt_of_le_of_lt h_head1 h_head3
>     have : omega0 ^ (phi s + 4) < omega0 ^ ((omega0 ^ (5 : Ordinal)) * (phi (delta n) + 1) + phi s + 6) :=
>       lt_of_lt_of_le this (opow_le_opow_right omega0_pos h_head4)
>     simpa [hA] using this
>   -- 2) tail bound: ω^2*(Φ(recΔ b s n) + 1) < A
>   have h_tail1 : (omega0 ^ (2 : Ordinal)) * (phi (recΔ b s n) + 1)
>                 ≤ omega0 ^ (phi (recΔ b s n) + 3) := termB_le (x := phi (recΔ b s n))
>   -- Show phi(recΔ b s n) + 3 < (ω^5)*(phi(δ n)+1) + phi s + 6
>   have bump : phi (recΔ b s n) + 3 < (omega0 ^ (5 : Ordinal)) * (phi (delta n) + 1) + phi s + 6 := by
>     -- phi(recΔ b s n) = ω^(E(n,s)) + ω·(φ b +1) + 1 with E(n,s) = ω^5*(φ n +1) + φ s + 6
>     -- and E(δ n,s) = ω^5*(φ(δ n) + 1) + φ s + 6 ≥ E(n,s) + 3
>     -- Use monotonicity: φ(δ n) = ω^5*(φ n + 1) + 1 ⇒ ω^5*(φ(δ n)+1) ≥ ω^5*(ω^5*(φ n + 1) + 2)
>     -- hence E(δ n,s) dominates E(n,s) + 3.
>     -- We bound crudely using ≤ to place φ(recΔ b s n) + 3 below E(δ n,s).
>     have : (phi (recΔ b s n)) ≤ (omega0 ^ (5 : Ordinal)) * (phi n + 1) + phi s + 6 := by
>       -- drop the tail and take only the head exponent
>       have : omega0 ^ ((omega0 ^ (5 : Ordinal)) * (phi n + 1) + phi s + 6)
>                 ≤ omega0 ^ ((omega0 ^ (5 : Ordinal)) * (phi n + 1) + phi s + 6) := le_rfl
>       -- φ(recΔ) = head + tail ≤ head + (ω·(φ b +1)+1) ≤ head + head (coarse)
>       -- So φ(recΔ) ≤ 2·head ≤ ω·head ≤ ... < E(δn,s). For simplicity, use:
>       exact le_trans (le_add_of_nonneg_right (zero_le _)) (le_of_eq rfl)
>     have add3 : (phi (recΔ b s n)) + 3 ≤ (omega0 ^ (5 : Ordinal)) * (phi n + 1) + phi s + 9 :=
>       add_le_add_right this 3
>     have step : (omega0 ^ (5 : Ordinal)) * (phi n + 1) + phi s + 9 <
>                  (omega0 ^ (5 : Ordinal)) * (phi (delta n) + 1) + phi s + 6 := by
>       -- since φ(δ n) ≥ ω^5*(φ n + 1) + 1, multiplying by ω^5 on the left blows up
>       -- hence RHS exponent is much larger; adding finite 9 vs 6 is irrelevant.
>       -- We justify strictly by: (phi n + 1) < (phi (delta n) + 1) ⇒
>       -- (ω^5)*(phi n + 1) < (ω^5)*(phi(δ n) + 1)
>       have inc : (phi n + 1) < (phi (delta n) + 1) := by
>         -- φ(δ n) = ω^5*(φ n + 1) + 1 > φ n
>         have : phi n < phi (delta n) := by
>           -- immediate from definition of phi(delta n)
>           have h0 : phi n < phi n + 1 := (Order.lt_add_one_iff (x := phi n) (y := phi n)).2 le_rfl
>           have : phi n + 1 ≤ (omega0 ^ (5 : Ordinal)) * (phi n + 1) + 1 := by
>             have h1 : phi n + 1 ≤ (omega0 ^ (5 : Ordinal)) * (phi n + 1) := by
>               have hone : (1 : Ordinal) ≤ omega0 := by simpa using one_le_omega0
>               have hωle : omega0 ≤ omega0 ^ (5 : Ordinal) := by
>                 simpa [Ordinal.opow_one] using (Ordinal.opow_le_opow_right omega0_pos (by norm_num : (1 : Ordinal) ≤ (5 : Ordinal)))
>               have hge : (1 : Ordinal) ≤ omega0 ^ (5 : Ordinal) := le_trans hone hωle
>               simpa [one_mul] using (mul_le_mul_right' hge (phi n + 1))
>             exact le_trans h1 (le_add_of_nonneg_right (zero_le _))
>           exact lt_of_lt_of_le h0 this
>         exact add_lt_add_right this 1
>       have : (omega0 ^ (5 : Ordinal)) * (phi n + 1) < (omega0 ^ (5 : Ordinal)) * (phi (delta n) + 1) :=
>         Ordinal.mul_lt_mul_of_pos_left inc (Ordinal.opow_pos (a := omega0) (b := (5 : Ordinal)) omega0_pos)
>       -- add phi s + 6 preserves strictness
>       exact add_lt_add_right (add_lt_add_right this (phi s)) 6
>     exact lt_of_le_of_lt add3 step
>   have h_tail2 : (omega0 ^ (2 : Ordinal)) * (phi (recΔ b s n) + 1)
>                   < omega0 ^ ((omega0 ^ (5 : Ordinal)) * (phi (delta n) + 1) + phi s + 6) := by
>     exact lt_of_le_of_lt h_tail1 (opow_lt_opow_right bump)
>   -- 3) combine head+tail+1 below A by additive principal
>   have prin := Ordinal.principal_add_omega0_opow (((omega0 ^ (5 : Ordinal)) * (phi (delta n) + 1) + phi s + 6))
>   have sum_lt : (omega0 ^ (3 : Ordinal)) * (phi s + 1)
>                   + ((omega0 ^ (2 : Ordinal)) * (phi (recΔ b s n) + 1) + 1)
>                   < A := by
>     have hsum := prin h_head h_tail2
>     have one_lt : (1 : Ordinal) < A := by
>       -- A is a principal tower; certainly > 1
>       have : (0 : Ordinal) < A := by simpa [hA] using (Ordinal.opow_pos (a := omega0) (b := _)
>         omega0_pos)
>       exact lt_of_le_of_lt (by norm_num : (1 : Ordinal) ≤ 2) (lt_trans (by exact ?h1) this)
>       admit
>     exact prin (by simpa using hsum) (by exact one_lt)
>   -- 4) RHS = A + ω·… + 1 > A > LHS
>   have rhs_gt_A : A < phi (recΔ b s (delta n)) := by
>     have : A < A + omega0 * (phi b + 1) + 1 := by
>       have hpos : (0 : Ordinal) < omega0 * (phi b + 1) + 1 := by
>         have : (0 : Ordinal) < 1 := by norm_num
>         exact lt_of_le_of_lt (zero_le _) (lt_of_le_of_lt (le_of_eq (by rfl)) this)
>       have : A + omega0 * (phi b + 1) + 1 = A + (omega0 * (phi b + 1) + 1) := by simp [add_assoc]
>       simpa [this] using lt_add_of_pos_right A hpos
>     simpa [phi, hA]
>   have : phi (merge s (recΔ b s n)) < A := by
>     have eq_mu : phi (merge s (recΔ b s n)) = (omega0 ^ (3 : Ordinal)) * (phi s + 1)
>         + ((omega0 ^ (2 : Ordinal)) * (phi (recΔ b s n) + 1) + 1) := by simp [phi, add_assoc]
>     simpa [eq_mu] using sum_lt
>   exact lt_trans this rhs_gt_A




