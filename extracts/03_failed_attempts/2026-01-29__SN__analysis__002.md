Purpose: Evidence extract (failed_attempts/analysis) documenting a failure or relevance; Duplicate of MUST_Review\Legacy\Meta_Lean_Archive\SN.lean.
Contents: Metadata header + excerpt from the source file.
Context: SN.lean (MetaSNFinal) uses kappaD + μ lex order; μ lemmas are imported from Termination.
Source: MUST_Review/Legacy/Meta_Lean_Archive/SN.lean
SHA256: 43A79BD489E4C403EA84B8515B985707E19240E1DB4E1C6ABD192C868FB612F7
FailureExplanation: Termination relies on external μ-drop lemmas rather than deriving them in-file.
FailureModeTags: unsupported_inference

Excerpt:
> /-- main: every kernel step strictly decreases the lex measure --/
> lemma measure_drop_of_step :
>   ∀ {a b : Trace}, Step a b → LexNatOrd (muHat b) (muHat a)
> | _, _, Step.R_int_delta t =>
>     -- integrate (delta t) → void
>     by
>       have hμ := MetaSN.mu_void_lt_integrate_delta t
>       -- κ(source) = κ t; κ(target) = 0
>       by_cases ht0 : kappaD t = 0
>       · -- equal κ; use μ-drop
>         have hk : kappaD (.void) = kappaD (.integrate (.delta t)) := by simp [kappaD, ht0]
>         exact drop_right hμ hk
>       · -- target κ < source κ
>         have hk : kappaD (.void) < kappaD (.integrate (.delta t)) := by
>           have : 0 < kappaD t := Nat.pos_of_ne_zero ht0
>           simpa [kappaD] using this
>         exact drop_left hk
>
> | _, _, Step.R_merge_void_left t =>
>     -- merge void t → t  (κ equal; μ drops)
>     by
>       have hμ := MetaSN.mu_lt_merge_void_left t
>       have hk : kappaD t = kappaD (.merge .void t) := by simp [kappaD]
>       exact drop_right hμ hk
>
> | _, _, Step.R_merge_void_right t =>
>     -- merge t void → t  (κ equal; μ drops)
>     by
>       have hμ := MetaSN.mu_lt_merge_void_right t
>       have hk : kappaD t = kappaD (.merge t .void) := by simp [kappaD]
>       exact drop_right hμ hk
>
> | _, _, Step.R_merge_cancel t =>
>     -- merge t t → t  (κ equal; μ drops)
>     by
>       have hμ := MetaSN.mu_lt_merge_cancel t
>       have hk : kappaD t = kappaD (.merge t t) := by simp [kappaD]
>       exact drop_right hμ hk
>
> | _, _, Step.R_rec_zero b s =>
>     -- recΔ b s void → b  (κ non-increasing; if strict, drop-left; else μ-drop)
>     by
>       have hμ := MetaSN.mu_lt_rec_base b s
>       have hle : kappaD b ≤ kappaD (.recΔ b s .void) := by
>         -- κ(rec b s void) = max (max κb κs) 0 = max κb κs ≥ κb
>         simpa [kappaD] using (Nat.le_max_left (kappaD b) (kappaD s))
>       by_cases hEq : kappaD b = kappaD (.recΔ b s .void)
>       · exact drop_right hμ hEq
>       · exact drop_left (Nat.lt_of_le_of_ne hle hEq)
>
> | _, _, Step.R_rec_succ b s n =>
>     -- recΔ b s (delta n) → app s (recΔ b s n)  (κ drops by 1)
>     by
>       exact drop_left (kappaD_drop_recSucc b s n)
>
> | _, _, Step.R_eq_refl a =>
>     -- eqW a a → void  (if κ a > 0: drop-left; else equal κ and μ-drop)
>     by
>       have hμ := MetaSN.mu_void_lt_eq_refl a
>       by_cases h0 : kappaD a = 0
>       · have hk : kappaD (.void) = kappaD (.eqW a a) := by simp [kappaD, h0]
>         exact drop_right hμ hk
>       · have hk : kappaD (.void) < kappaD (.eqW a a) := by
>           have : 0 < kappaD a := Nat.pos_of_ne_zero h0
>           simpa [kappaD, Nat.max_self] using this
>         exact drop_left hk
>
> | a, b, Step.R_eq_diff hneq =>
>     -- eqW a b → integrate (merge a b)  (κ equal; μ drops)
>     by
>       have hμ := MetaSN.mu_lt_eq_diff a b
>       have hk : kappaD (.eqW a b) = kappaD (.integrate (.merge a b)) := by
>         simp [kappaD, Nat.max_assoc, Nat.max_comm, Nat.max_left_comm]
>       exact drop_right hμ hk
>
> /-- reverse relation for forward SN --/





